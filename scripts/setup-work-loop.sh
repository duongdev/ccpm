#!/bin/bash
# setup-work-loop.sh - Initialize CCPM work loop state
# Based on ralph-wiggum pattern for iterative task completion

set -e

# Configuration
STATE_FILE=".claude/ccpm-work-loop.local.md"
DEFAULT_MAX_ITERATIONS=30
DEFAULT_COMPLETION_PROMISE="ALL_ITEMS_COMPLETE"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Print usage
print_usage() {
  cat << EOF
Usage: /ccpm:work:loop [ISSUE-ID] [OPTIONS]

Start an autonomous work loop that iterates through all checklist items.

Options:
  --max-iterations N    Maximum iterations before stopping (default: $DEFAULT_MAX_ITERATIONS)
  --resume              Resume a paused loop (after blocker resolved)
  -h, --help            Show this help message

Examples:
  /ccpm:work:loop WORK-26
  /ccpm:work:loop WORK-26 --max-iterations 50
  /ccpm:work:loop --resume

The loop continues until:
  - All checklist items complete (agent outputs completion promise)
  - Max iterations reached (safety limit)
  - Blocker detected (loop pauses for user input)
EOF
}

# Parse arguments
ISSUE_ID=""
MAX_ITERATIONS=$DEFAULT_MAX_ITERATIONS
RESUME_MODE=false

while [[ $# -gt 0 ]]; do
  case $1 in
    --max-iterations)
      if [[ -z "$2" || ! "$2" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}Error: --max-iterations requires a positive integer${NC}"
        exit 1
      fi
      MAX_ITERATIONS="$2"
      shift 2
      ;;
    --resume)
      RESUME_MODE=true
      shift
      ;;
    -h|--help)
      print_usage
      exit 0
      ;;
    -*)
      echo -e "${RED}Unknown option: $1${NC}"
      print_usage
      exit 1
      ;;
    *)
      if [[ -z "$ISSUE_ID" ]]; then
        ISSUE_ID="$1"
      fi
      shift
      ;;
  esac
done

# Handle resume mode
if [[ "$RESUME_MODE" == "true" ]]; then
  if [[ ! -f "$STATE_FILE" ]]; then
    echo -e "${RED}Error: No active work loop to resume${NC}"
    echo "Start a new loop with: /ccpm:work:loop ISSUE-ID"
    exit 1
  fi

  # Read existing state
  ISSUE_ID=$(grep -E "^issue_id:" "$STATE_FILE" | sed 's/issue_id: "\(.*\)"/\1/')
  ITERATION=$(grep -E "^iteration:" "$STATE_FILE" | sed 's/iteration: //')
  MAX_ITERATIONS=$(grep -E "^max_iterations:" "$STATE_FILE" | sed 's/max_iterations: //')

  echo -e "${CYAN}Resuming work loop for ${ISSUE_ID}${NC}"
  echo -e "  Iteration: ${ITERATION} of ${MAX_ITERATIONS}"
  echo ""
  echo "Continue implementing the next uncompleted checklist item."
  exit 0
fi

# Validate issue ID
if [[ -z "$ISSUE_ID" ]]; then
  # Try to detect from git branch
  BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
  if [[ -n "$BRANCH" ]]; then
    DETECTED_ID=$(echo "$BRANCH" | grep -oE '[A-Z]+-[0-9]+' | head -1)
    if [[ -n "$DETECTED_ID" ]]; then
      ISSUE_ID="$DETECTED_ID"
      echo -e "${BLUE}Detected issue from branch: ${ISSUE_ID}${NC}"
    fi
  fi
fi

if [[ -z "$ISSUE_ID" ]]; then
  echo -e "${RED}Error: Issue ID required${NC}"
  echo "Usage: /ccpm:work:loop ISSUE-ID"
  exit 1
fi

# Validate issue ID format
if [[ ! "$ISSUE_ID" =~ ^[A-Z]+-[0-9]+$ ]]; then
  echo -e "${RED}Error: Invalid issue ID format: ${ISSUE_ID}${NC}"
  echo "Expected format: PROJ-123 (uppercase letters, hyphen, numbers)"
  exit 1
fi

# Check if loop already active
if [[ -f "$STATE_FILE" ]]; then
  EXISTING_ID=$(grep -E "^issue_id:" "$STATE_FILE" | sed 's/issue_id: "\(.*\)"/\1/')
  if [[ "$EXISTING_ID" == "$ISSUE_ID" ]]; then
    echo -e "${YELLOW}Warning: Loop already active for ${ISSUE_ID}${NC}"
    echo "Use --resume to continue, or cancel with /ccpm:cancel-work-loop"
    exit 1
  else
    echo -e "${YELLOW}Warning: Replacing active loop for ${EXISTING_ID} with ${ISSUE_ID}${NC}"
  fi
fi

# Get current git branch
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")

# Create .claude directory if needed
mkdir -p .claude

# Get current timestamp
TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

# Create state file with YAML frontmatter
cat > "$STATE_FILE" << EOF
---
issue_id: "${ISSUE_ID}"
current_item_index: 0
total_items: 0
iteration: 1
max_iterations: ${MAX_ITERATIONS}
completion_promise: "${DEFAULT_COMPLETION_PROMISE}"
started_at: "${TIMESTAMP}"
last_sync_at: "${TIMESTAMP}"
items_completed: []
blockers: []
branch: "${CURRENT_BRANCH}"
---

## Work Loop State

This file tracks the autonomous work loop for issue ${ISSUE_ID}.

**Do not edit this file manually** - it is managed by the work loop system.

### Loop Control
- To cancel: \`/ccpm:cancel-work-loop\`
- To resume (after blocker): \`/ccpm:work:loop --resume\`

### Completion Signal
When ALL checklist items are genuinely complete, output:
\`\`\`
<promise>${DEFAULT_COMPLETION_PROMISE}</promise>
\`\`\`

### Blocker Signal
If blocked on an item, output:
\`\`\`
Status: Blocked
\`\`\`
EOF

# Output success message and initial prompt
echo -e "${GREEN}Starting work loop for ${ISSUE_ID}${NC}"
echo ""
echo -e "  ${CYAN}Max iterations:${NC} ${MAX_ITERATIONS}"
echo -e "  ${CYAN}Branch:${NC} ${CURRENT_BRANCH}"
echo -e "  ${CYAN}State file:${NC} ${STATE_FILE}"
echo ""
echo -e "${YELLOW}The loop will continue until:${NC}"
echo "  1. All checklist items complete (output <promise>${DEFAULT_COMPLETION_PROMISE}</promise>)"
echo "  2. Max iterations reached (${MAX_ITERATIONS})"
echo "  3. Blocker detected (output 'Status: Blocked')"
echo ""
echo -e "${GREEN}Starting iteration 1...${NC}"
echo ""

# Output initial prompt for Claude to pick up
cat << 'INITIAL_PROMPT'
## Work Loop Started

**Iteration**: 1
**Mode**: Autonomous implementation

**Instructions**:
1. Fetch the issue checklist from Linear using ccpm:linear-operations agent
2. Identify the first uncompleted checklist item
3. Delegate implementation to the appropriate specialized agent
4. After implementation, sync progress to Linear
5. Move to the next item

**Completion Protocol**:
- When ALL items are genuinely complete, output: <promise>ALL_ITEMS_COMPLETE</promise>
- If blocked on an item, output: Status: Blocked

**Important**:
- Do NOT output the completion promise until ALL items are truly done
- Do NOT skip items - implement each one
- Sync to Linear after each item completion
INITIAL_PROMPT

exit 0
